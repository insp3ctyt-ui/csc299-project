The main goal of this final project was to build a Personal Knowledge Management System (PKMS) and Task Manager using Python. I’ve done some coding assignments before, but this one was different because it was entirely focused on using AI coding assistants to plan, specify, and actually write the software. The idea was to create something that could run on any computer (Windows, Mac, Linux) and store data in a way that was easy to manage.

For my development process, I used Gemini as my main tool for coding. The workflow between me and Gemini was me telling the AI what I needed to build based on the professor’s requirements, it would suggest a plan or some code, and then I would try to run it. A lot of the time I ran into specific errors that the AI didn’t predict, so I either had to figure out what the problem was myself and fix it, or I would  feed the errors back into the AI until it figured out what the problem was and gave me a fix.

For this project I used uv for managing the packages because it’s faster and cleaner than just using pip. For the actual application, I used typer to make the command-line interface look nice, and SQLModel with SQLite for the database. I went with SQLite because I wanted all my data to be in a single file (project.db) that I could just move around if I needed to, kind of like how the JSON file worked in the earlier assignments.

In Prototype 1, the biggest struggle was just getting the project structure set up. I was trying to use uv to build the package, but the hatchling kept crashing because it couldn’t find my code. I had to mess around with the pyproject.toml file a lot to finally get it to recognize my directory. Also, since I’m using a Mac with the zsh terminal, I ran into a weird issue where I couldn’t install the dev dependencies. The AI told me to run pip install -e .[dev], but zsh hated the brackets. I had to figure out that I needed to put quotes around it (".[dev]") to make it work.

Prototype 2 was where I added the ability to mark tasks as done and delete them, plus I added the tests. The testing part was probably the most stressful part of the whole project. I was trying to use pytest to test the database functions, but the tests kept failing. It turned out I was doing something called "monkeypatching" wrong. I was trying to replace the database session in the main file, but the code was actually importing it from a different file. It took a while to realize I had to patch the function exactly where it was being used. I had to resend the error messages back to Gemini a bunch to figure this out, but it didn’t take super long to figure it out.

Prototype 3 is where I turned the app into a real chat interface. Instead of typing a command and having the program exit immediately, I built a loop so I could stay inside the app and type commands like tasks list or notes added over and over. This part was probably the easiest, since I wasn't changing much of how the PKMS system actually worked, so adding the chat interface was super quick and had no errors.

Prototype 4/the Final Product was the final version where I connected everything. I added a feature to link tasks to notes and an AI agent that could actually plan tasks for me. I ran into a silent bug here that was really confusing. When I tried to link a task to a note, the program didn’t crash, but it also didn’t do anything. It turned out the code was looking for a string named "Note" instead of the actual Note object definition. Once I fixed that import, it worked perfectly.

Overall, this project taught me that AI is a really powerful tool for getting started and writing code, but you still need to know what you’re doing to fix the weird errors that pop up. It was a lot of work, but having a working app at the end that I can actually talk to is pretty rewarding and helps fixing bugs that I didn’t even know existed, instead of going in circles on google and different websites trying to figure out what I did wrong. I really liked the workflow, but I think that in the future I should probably have a more hands-on approach to actually doing the coding instead of solely relying on AI.
