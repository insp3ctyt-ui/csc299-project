#!/usr/bin/env python3
"""
Simple CLI Task Manager

Single-file, portable, self-contained command-line application.
Stores all data in a single JSON file at the project root: `data.json`.

Usage:
  python cli_app.py add "Title" --desc "optional description"
  python cli_app.py list
  python cli_app.py get <id>
  python cli_app.py update <id> --title "New" --desc "New desc" --done (toggle)
  python cli_app.py delete <id>

Author: Generated by GitHub Copilot agent
"""

import argparse
import json
import os
import sys
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional

ROOT = os.path.dirname(os.path.abspath(__file__))
DATA_FILE = os.path.join(ROOT, "data.json")

# Minimal schema: store tasks as list of objects with id, title, description, done, created_at, updated_at


def load_data() -> Dict[str, Any]:
    """Load JSON data from DATA_FILE. If file absent, return default structure."""
    if not os.path.exists(DATA_FILE):
        return {"tasks": [], "next_id": 1}
    with open(DATA_FILE, "r", encoding="utf-8") as f:
        try:
            return json.load(f)
        except json.JSONDecodeError:
            # If file is corrupted, back it up and start fresh
            backup = DATA_FILE + ".corrupt." + datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
            os.rename(DATA_FILE, backup)
            print(f"Warning: data file was corrupted. Backed up to {backup}")
            return {"tasks": [], "next_id": 1}


def save_data(data: Dict[str, Any]) -> None:
    """Save data atomically to DATA_FILE."""
    tmp = DATA_FILE + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
    os.replace(tmp, DATA_FILE)


def add_task(title: str, description: Optional[str]) -> Dict[str, Any]:
    data = load_data()
    task = {
        "id": data.get("next_id", 1),
        "title": title,
        "description": description or "",
        "done": False,
                "created_at": datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
                "updated_at": datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
    }
    data.setdefault("tasks", []).append(task)
    data["next_id"] = task["id"] + 1
    save_data(data)
    return task


def list_tasks(show_all: bool = True) -> List[Dict[str, Any]]:
    data = load_data()
    tasks = data.get("tasks", [])
    if not show_all:
        tasks = [t for t in tasks if not t.get("done")]
    return tasks


def get_task(task_id: int) -> Optional[Dict[str, Any]]:
    data = load_data()
    for t in data.get("tasks", []):
        if int(t.get("id")) == int(task_id):
            return t
    return None


def update_task(task_id: int, title: Optional[str], description: Optional[str], toggle_done: Optional[bool]) -> Optional[Dict[str, Any]]:
    data = load_data()
    for t in data.get("tasks", []):
        if int(t.get("id")) == int(task_id):
            if title is not None:
                t["title"] = title
            if description is not None:
                t["description"] = description
            if toggle_done:
                t["done"] = not bool(t.get("done"))
            t["updated_at"] = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
            save_data(data)
            return t
    return None


def delete_task(task_id: int) -> bool:
    data = load_data()
    tasks = data.get("tasks", [])
    new_tasks = [t for t in tasks if int(t.get("id")) != int(task_id)]
    if len(new_tasks) == len(tasks):
        return False
    data["tasks"] = new_tasks
    save_data(data)
    return True


def mark_done(task_id: int) -> Optional[Dict[str, Any]]:
    """Mark the task with task_id as done. Return the task or None if not found."""
    data = load_data()
    for t in data.get("tasks", []):
        if int(t.get("id")) == int(task_id):
            t["done"] = True
            t["updated_at"] = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
            save_data(data)
            return t
    return None


def print_task(t: Dict[str, Any]) -> None:
    print(f"[{t['id']}] {'x' if t.get('done') else ' '} {t.get('title')}")
    if t.get("description"):
        print(f"    {t.get('description')}")
    print(f"    created: {t.get('created_at')} updated: {t.get('updated_at')}")


def main(argv=None):
    parser = argparse.ArgumentParser(prog="cli_app.py", description="Simple single-file task CLI using a root JSON file")
    sub = parser.add_subparsers(dest="cmd")

    # Required commands per spec:
    # add <DESCRIPTION>
    p_add = sub.add_parser("add", help="Add a new pending task with DESCRIPTION")
    p_add.add_argument("description", help="Task description")

    # list
    p_list = sub.add_parser("list", help="List all tasks with ID and status")

    # done <ID>
    p_done = sub.add_parser("done", help="Mark task with ID as done")
    p_done.add_argument("id", type=int, help="ID of task to mark done")

    # delete <ID>
    p_del = sub.add_parser("delete", help="Delete task with ID")
    p_del.add_argument("id", type=int, help="ID of task to delete")

    args = parser.parse_args(argv)

    if args.cmd == "add":
        # Per spec: add <DESCRIPTION> creates a pending task with a unique id
        task = add_task(args.description, None)
        # Simple output: show new ID
        print(task["id"])
        return 0

    if args.cmd == "list":
        tasks = list_tasks(show_all=True)
        if not tasks:
            return 0
        # Print lines: <ID> <status> <description>
        for t in tasks:
            status = "done" if t.get("done") else "pending"
            desc = t.get("title") or t.get("description") or ""
            print(f"{t['id']} {status} {desc}")
        return 0

    if args.cmd == "done":
        t = mark_done(args.id)
        if not t:
            print("Not found")
            return 2
        # No extra output required; print the id for confirmation
        print(t["id"])
        return 0

    if args.cmd == "delete":
        ok = delete_task(args.id)
        if not ok:
            print("Not found")
            return 2
        # print deleted id
        print(args.id)
        return 0

    parser.print_help()
    return 1


if __name__ == "__main__":
    raise SystemExit(main())
